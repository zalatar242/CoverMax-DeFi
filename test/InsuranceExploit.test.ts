import { expect } from "chai";
import { ethers } from "hardhat";

describe("SplitInsurance Security Tests", function () {
  let splitInsurance: any;
  let mockDai: any;
  let mockADai: any;
  let mockCDai: any;
  let mockAaveLendingPool: any;
  let deployer: any;
  let attacker: any;
  let user: any;

  beforeEach(async function () {
    [deployer, attacker, user] = await ethers.getSigners();

    // Deploy MockDAI with isCToken = false (regular DAI)
    const MockDAIFactory = await ethers.getContractFactory("MockDAI", deployer);
    mockDai = await MockDAIFactory.deploy(false);
    await mockDai.deploymentTransaction()?.wait();

    // Deploy Mock Tokens (aDAI with isCToken = false and cDAI with isCToken = true)
    mockADai = await MockDAIFactory.deploy(false);
    await mockADai.deploymentTransaction()?.wait();
    mockCDai = await MockDAIFactory.deploy(true);
    await mockCDai.deploymentTransaction()?.wait();

    // Setup cDAI with DAI as underlying
    await mockCDai.setUnderlyingToken(await mockDai.getAddress());

    // Deploy Mock Aave Lending Pool with aToken address
    const MockAaveLendingPoolFactory = await ethers.getContractFactory("MockAaveLendingPool", deployer);
    mockAaveLendingPool = await MockAaveLendingPoolFactory.deploy(await mockADai.getAddress());
    await mockAaveLendingPool.deploymentTransaction()?.wait();

    // Deploy SplitInsurance with mock addresses
    const SplitInsuranceFactory = await ethers.getContractFactory("SplitInsurance", deployer);
    splitInsurance = await SplitInsuranceFactory.deploy(
      await mockDai.getAddress(),
      await mockAaveLendingPool.getAddress(),
      await mockADai.getAddress(),
      await mockCDai.getAddress()
    );
    await splitInsurance.deploymentTransaction()?.wait();

    // Mint some MockDAI to attacker
    await mockDai.adminMint(attacker.address, "1000000000000000000000"); // 1000 tokens with 18 decimals
  });

  it("Should demonstrate odd deposit reduction in splitRisk", async function () {
    const oddAmount = ethers.parseUnits("101", 0); // 101 with no decimals
    await mockDai.connect(attacker).approve(await splitInsurance.getAddress(), oddAmount);
    const tx = await splitInsurance.connect(attacker).splitRisk(oddAmount);
    const receipt = await tx.wait();

    // Check that the event contains the reduced amount
    const events = receipt.logs.filter(
      (log: { topics: string[] }) => log.topics[0] === splitInsurance.interface.getEvent("RiskSplit").topicHash
    );
    expect(events.length).to.equal(1, "RiskSplit event not found");
    const event = events[0];
    const decodedEvent = splitInsurance.interface.parseLog({
      topics: event.topics,
      data: event.data
    });
    expect(decodedEvent.args.amount_c).to.equal(oddAmount - BigInt(1));
  });

  it("Should revert invest() if called before issuance period", async function () {
    await expect(splitInsurance.invest()).to.be.revertedWith("split: still in issuance period");
  });

  it("Exploit: Calling claim before insurance period should revert", async function () {
    await expect(splitInsurance.claim(10, 10)).to.be.revertedWith("split: can not claim during insurance period");
  });

  it("Exploit: Activate liquid mode in claimA when invest() was never called", async function () {
    const T1 = Number(await splitInsurance.T1());
    await ethers.provider.send("evm_setNextBlockTimestamp", [T1 + 1]);
    await ethers.provider.send("evm_mine", []);

    await expect(splitInsurance.claimA(10, 0))
      .to.be.revertedWith("split: insufficient tranche A tokens");
  });

  it("Exploit: Calling divest() before T1 should revert", async function () {
    const depositAmount = ethers.parseUnits("1000", 18);
    const splitInsuranceAddress = await splitInsurance.getAddress();

    // Deposit and approve for split risk
    await mockDai.connect(attacker).approve(splitInsuranceAddress, depositAmount);
    await splitInsurance.connect(attacker).splitRisk(depositAmount);

    // Move time to just after S (issuance period)
    const S = Number(await splitInsurance.S());
    await ethers.provider.send("evm_setNextBlockTimestamp", [S + 1]);
    await ethers.provider.send("evm_mine", []);

    // Approve for protocol interactions
    await mockDai.approve(splitInsuranceAddress, ethers.MaxUint256);
    await splitInsurance.invest();

    // Try to divest before T1 (should fail)
    await expect(splitInsurance.divest()).to.be.revertedWith("split: still in insurance period");
  });

  it("Exploit: Should revert when trying to double claim tranches", async function() {
    const depositAmount = ethers.parseUnits("1000", 18); // 1000 DAI
    const splitInsuranceAddress = await splitInsurance.getAddress();
    await mockDai.connect(attacker).approve(splitInsuranceAddress, depositAmount);
    await splitInsurance.connect(attacker).splitRisk(depositAmount);

    // Move time to T2 when A tranches can be claimed
    const T2 = Number(await splitInsurance.T2());
    await ethers.provider.send("evm_setNextBlockTimestamp", [T2 + 1]);
    await ethers.provider.send("evm_mine", []);

    const halfAmount = depositAmount / BigInt(2);
    await splitInsurance.connect(attacker).claimA(halfAmount, BigInt(0));

    await expect(
      splitInsurance.connect(attacker).claimA(halfAmount, BigInt(0))
    ).to.be.revertedWith("split: insufficient tranche A tokens");
  });
});
