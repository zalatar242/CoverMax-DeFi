import { expect } from "chai";
import { ethers } from "hardhat";
import { Contract, ContractFactory } from "ethers";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";
import { MockUSDC, ILendingAdapter, Tranche, MockAaveLendingPool } from "../typechain-types";
import { Insurance } from "../typechain-types/contracts/Insurance.sol";

describe("Insurance Security Tests", function () {
  let insurance: Insurance;
  let mockUsdc: MockUSDC;
  let mockAaveLendingPool: MockAaveLendingPool;
  let deployer: HardhatEthersSigner;
  let attacker: HardhatEthersSigner;
  let user: HardhatEthersSigner;
  let trancheA: Tranche;
  let trancheB: Tranche;
  let trancheC: Tranche;

  // Helper function to advance time
  const advanceTime = async (seconds: number) => {
    await ethers.provider.send("evm_increaseTime", [seconds]);
    await ethers.provider.send("evm_mine", []);
  };

  // Constants for time periods
  const DAY = 24 * 60 * 60;
  const ISSUANCE_PERIOD = 7 * DAY;
  const INSURANCE_PERIOD = 28 * DAY;

  beforeEach(async function () {
    [deployer, attacker, user] = await ethers.getSigners();

    // Deploy MockUSDC
    const MockUSDC: ContractFactory = await ethers.getContractFactory("MockUSDC");
    mockUsdc = await MockUSDC.deploy() as MockUSDC;

    // Deploy Mock Aave Lending Pool
    const MockAaveLendingPool: ContractFactory = await ethers.getContractFactory("MockAaveLendingPool");
    mockAaveLendingPool = await MockAaveLendingPool.deploy() as MockAaveLendingPool;

    // Deploy Insurance contract
    const Insurance: ContractFactory = await ethers.getContractFactory("Insurance");
    insurance = await Insurance.deploy(await mockUsdc.getAddress()) as Insurance;

    // Get Tranche token contracts
    const trancheAAddress = await insurance.A();
    const trancheBAddress = await insurance.B();
    const trancheCAddress = await insurance.C();

    const Tranche: ContractFactory = await ethers.getContractFactory("Tranche");
    trancheA = Tranche.attach(trancheAAddress) as Tranche;
    trancheB = Tranche.attach(trancheBAddress) as Tranche;
    trancheC = Tranche.attach(trancheCAddress) as Tranche;

    // Add lending adapter
    await insurance.addLendingAdapter(await mockAaveLendingPool.getAddress());

    // Mint USDC to attacker (1,000,000 USDC)
    await mockUsdc.mint(attacker.address, ethers.parseUnits("1000000", 6));
    await mockUsdc.connect(attacker).approve(await insurance.getAddress(), ethers.parseUnits("1000000", 6));
  });

  describe("Access Control", function () {
    it("Should prevent unauthorized lending adapter addition", async function () {
      const MockAaveLendingPool2 = await ethers.getContractFactory("MockAaveLendingPool");
      const mockAaveLendingPool2 = await MockAaveLendingPool2.deploy();

      // First try with attacker - should fail
      await expect(insurance.connect(attacker).addLendingAdapter(await mockAaveLendingPool2.getAddress()))
        .to.be.revertedWithCustomError(insurance, "OwnableUnauthorizedAccount")
        .withArgs(attacker.address);

      // Even deployer should fail after issuance period
      await advanceTime(ISSUANCE_PERIOD + 1);
      await expect(insurance.connect(deployer).addLendingAdapter(await mockAaveLendingPool2.getAddress()))
        .to.be.revertedWith("Insurance: past issuance period");
    });

    it("Should prevent adapter addition after issuance period", async function () {
      await advanceTime(ISSUANCE_PERIOD + 1);
      await expect(insurance.connect(deployer).addLendingAdapter(attacker.address))
        .to.be.revertedWith("Insurance: past issuance period");
    });

    it("Should prevent adapter removal after issuance period", async function () {
      await advanceTime(ISSUANCE_PERIOD + 1);
      await expect(insurance.connect(deployer).removeLendingAdapter(0))
        .to.be.revertedWith("Insurance: past issuance period");
    });
  });

  describe("Input Validation", function () {
    it("Should prevent amount not divisible by 3 in splitRisk", async function () {
      const amount = ethers.parseUnits("100", 6);
      await expect(insurance.connect(attacker).splitRisk(amount))
        .to.be.revertedWith("Insurance: amount must be divisible by 3");
    });

    it("Should prevent zero amount in splitRisk", async function () {
      await expect(insurance.connect(attacker).splitRisk(0))
        .to.be.revertedWith("Insurance: amount too low");
    });

    it("Should prevent extremely large amounts in splitRisk", async function () {
      const largeAmount = ethers.parseUnits("999999", 6); // ~1M USDC (divisible by 3)
      // Should succeed with large valid amount
      await insurance.connect(attacker).splitRisk(largeAmount);

      // Verify correct allocation
      const expectedTranche = largeAmount / 3n;
      expect(await trancheA.balanceOf(attacker.address)).to.equal(expectedTranche);
    });
  });

  describe("Time-based Controls", function () {
    it("Should prevent invest() before issuance period ends", async function () {
      await expect(insurance.invest())
        .to.be.revertedWith("Insurance: still in issuance");
    });

    it("Should prevent invest() after insurance period", async function () {
      await advanceTime(ISSUANCE_PERIOD + INSURANCE_PERIOD + 1);
      await expect(insurance.invest())
        .to.be.revertedWith("Insurance: past insurance period");
    });

    it("Should prevent divest() before insurance period ends", async function () {
      const amount = ethers.parseUnits("300", 6);
      await insurance.connect(attacker).splitRisk(amount);
      await advanceTime(ISSUANCE_PERIOD);
      await insurance.invest();

      await expect(insurance.divest())
        .to.be.revertedWith("Insurance: still in insurance period");
    });

    it("Should prevent divest() after claim period starts", async function () {
      const amount = ethers.parseUnits("300", 6);
      await insurance.connect(attacker).splitRisk(amount);
      await advanceTime(ISSUANCE_PERIOD);
      await insurance.invest();
      await advanceTime(INSURANCE_PERIOD + 2 * DAY); // Past T2

      await expect(insurance.divest())
        .to.be.revertedWith("Insurance: in claim period");
    });
  });

  describe("Claim Validation", function () {
    it("Should prevent claiming before liquid mode", async function () {
      await expect(insurance.connect(attacker).claim(10, 10, 10))
        .to.be.revertedWith("Insurance: not in liquid mode");
    });

    it("Should prevent double claiming of tranches", async function () {
      const amount = ethers.parseUnits("300", 6);
      await insurance.connect(attacker).splitRisk(amount);
      await advanceTime(ISSUANCE_PERIOD + INSURANCE_PERIOD);
      await insurance.divest();

      // First claim should succeed
      await insurance.connect(attacker).claim(amount/3n, 0, 0);

      // Second claim should fail
      await expect(insurance.connect(attacker).claim(amount/3n, 0, 0))
        .to.be.revertedWith("Insurance: insufficient A balance");
    });

    it("Should prevent claiming more than owned", async function () {
      const amount = ethers.parseUnits("300", 6);
      await insurance.connect(attacker).splitRisk(amount);
      await advanceTime(ISSUANCE_PERIOD + INSURANCE_PERIOD);
      await insurance.divest();

      await expect(insurance.connect(attacker).claim(amount, 0, 0))
        .to.be.revertedWith("Insurance: insufficient A balance");
    });

    it("Should prevent claim manipulation through transfer", async function () {
      const amount = ethers.parseUnits("300", 6);
      await insurance.connect(attacker).splitRisk(amount);
      await advanceTime(ISSUANCE_PERIOD + INSURANCE_PERIOD);
      await insurance.divest();

      // Record initial balances
      const initialBalance = await mockUsdc.balanceOf(attacker.address);

      // Split up the tranches
      const trancheAmount = amount / 3n;
      await trancheA.connect(attacker).transfer(user.address, trancheAmount);

      // Approve and claim
      await trancheA.connect(user).approve(await insurance.getAddress(), trancheAmount);
      await trancheB.connect(attacker).approve(await insurance.getAddress(), trancheAmount);
      await trancheC.connect(attacker).approve(await insurance.getAddress(), trancheAmount);

      // User claims A tranche, attacker claims B and C tranches
      await insurance.connect(user).claim(trancheAmount, 0, 0);
      await insurance.connect(attacker).claim(0, trancheAmount, trancheAmount);

      // Calculate total claimed
      const finalBalanceAttacker = await mockUsdc.balanceOf(attacker.address);
      const finalBalanceUser = await mockUsdc.balanceOf(user.address);
      const totalClaimed = (finalBalanceAttacker - initialBalance) + finalBalanceUser;

      // Total claimed should equal original deposit
      expect(totalClaimed).to.equal(amount);
    });
  });

  describe("Investment Security", function () {
    it("Should handle investment never happening", async function () {
      const amount = ethers.parseUnits("300", 6);
      await insurance.connect(attacker).splitRisk(amount);
      await advanceTime(ISSUANCE_PERIOD + INSURANCE_PERIOD);

      // Should be able to divest without investing
      await insurance.divest();
      expect(await insurance.inLiquidMode()).to.be.true;

      // Payouts should be equal to original amounts
      const payout = await insurance.usdcPayoutA();
      expect(payout).to.equal(ethers.parseUnits("1", 27)); // RAY
    });

    it("Should prevent lending adapter manipulation", async function () {
      const amount = ethers.parseUnits("300", 6);
      await insurance.connect(attacker).splitRisk(amount);
      await advanceTime(ISSUANCE_PERIOD);

      // Try to manipulate adapter
      await mockAaveLendingPool.setShouldRevert(true);

      // Investment should still succeed but emit error
      await expect(insurance.invest())
        .to.emit(mockAaveLendingPool, "LendingError")
        .withArgs(await mockUsdc.getAddress(), amount, 1);

      expect(await insurance.isInvested()).to.be.true;
    });

    it("Should prevent tranche token manipulation", async function () {
      const amount = ethers.parseUnits("300", 6);
      await insurance.connect(attacker).splitRisk(amount);

      // Verify allocation is exactly equal
      const trancheAmount = amount / 3n;
      expect(await trancheA.balanceOf(attacker.address)).to.equal(trancheAmount);
      expect(await trancheB.balanceOf(attacker.address)).to.equal(trancheAmount);
      expect(await trancheC.balanceOf(attacker.address)).to.equal(trancheAmount);

      // Try to transfer more than owned
      await expect(trancheA.connect(attacker).transfer(user.address, trancheAmount + 1n))
        .to.be.reverted;
    });
  });
});
